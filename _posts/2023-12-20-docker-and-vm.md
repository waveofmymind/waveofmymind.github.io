---

title: "도커와 VM"
date: 2023-12-20 09:29:00 +0900
aliases: 
tags: [Docker,Container,Virtual Machine,VM]
categories: [Docker]

---

본 글에서는 VM 기술에서 도커가 탄생하기까지와, 도커가 컨테이너 자원을 어떻게 할당하는 지에 대해서 다루는 글입니다.

## **VM 기술의 장점과 단점**

> 하나의 서버에서 여러개의 컴퓨팅 환경을 구동하기 위해서는 어떻게 해야할까?
{: .prompt-info}

![hypervisor](/assets/img/2023-12-20-docker-and-vm/hypervisor.webp)

이를 위해서 사용된 것이 Virtual Machine, 즉 가상 머신 기술이다.

호스트와 다른 운영체제, 다른 환경의 응용 프로그램을 실행시키기 위해 사용한다.

![vm architecture](/assets/img/2023-12-20-docker-and-vm/vm-architecture.webp)

예를 들어 윈도우에서 리눅스 환경의 앱을 실행시키고자 할 경우, 게스트 OS(리눅스 및 S/W화 된 H/W)를 설치하고, 그 위에서 앱을 실행시킬 수 있다.

> 리눅스 앱이 네트워크 통신을 위해 사용하는 NIC도 소프트웨어이며, 이 경우 호스트 OS의 NIC를 L2 스위치로써 활용한다.

특히 하이퍼바이저 기반의 가상화를 많이 사용했는데, VM이라는 독립된 가상 환경을 만들고 하이퍼바이저가 VM에 설치된 게스트 OS를 구동 및 모니터링을 할 수 있었다.

멀티 프로세스처럼, 각 VM은 자원이 독립적으로 할당 받아 하나의 VM에서 발생한 문제가 다른 VM으로 영향을 주지 않는 장점이 있었다.

반면에 단점도 명확하다.

게스트 OS 위에 소프트웨어가 실행되기 때문에 게스트 OS가 반드시 설치되어야했고, 그에 필요한 자원을 호스트에서 할당해주어야 했다.

그렇기 때문에 VM이 많아질수록 Guest OS의 개수도 비례해서 증가하고, 필요한 자원도 증가하는 것이다.

또한 VM이 많아질수록, 게스트 OS나 소프트웨어의 버전 관리를 하는데 있어서 번거로움이 있었다.

그라고 우리가 가상 기술을 사용하는 이유는, 다른 환경의 OS를 사용하기 위해서가 아닌 다른 환경의 소프트웨어를 사용하고 싶기 때문이다.

그렇기 때문에 매번 실행시키고자 하는 VM에 게스트 OS가 설치되는 것에 대해 당위성이 제기되었고, 이에 따라 가상화 컨테이너 기술이 발전하게 되었다고 볼 수 있다.

## **Docker**

![container architecture](/assets/img/2023-12-20-docker-and-vm/container.webp)

가상화된 환경에서 컨테이너 환경으로 넘어가면, 반복되는 게스트 OS 없이 App 실행에 필요한 라이브러리를 가지고 컨테이너가 올라가 있음을 알 수 있다.

게스트 OS 없이 호스트 OS를 통일한 시스템의 다른 컨테이너와 공유하고, 격리된 환경에서 애플리케이션을 실행할 필요가 있었다.

그를 위해서는 컨테이너 자체가 독립적으로 실행될 수 있어야했고, 컨테이너를 실행시키기 위한 컨테이너 이미지에는 코드, 런타임, 시스템 도구, 시스템 라이브러리 및 설정 등 소프트웨어를 실행하는데 필요한 모든 것이 포함되었다.

그리고 이미지를 활용해서 호스트 시스템 위에서 실행시키면 다른 OS에서 동작하는 것과 같은 가상 실행 환경을 제공할 수 있었다.

기존의 VM과 달리, 컨테이너마다 게스트 OS가 필요하지 않으며, 호스트 OS 커널을 사용해 여러 개의 컨테이너를 실행한다.

그리고 컨테이너가 자원을 사용하고, 할당받기 위해서는 컨테이너 엔진이 필요한데,

컨테이너가 하드웨어를 이용하고자 할 때에는 **컨테이너 엔진**이 컨테이너의 시스템 콜을 받아 호스트 OS 커널에게 요청하게 되고, 응답을 컨테이너에게 내려주었다.

## 도커 클라이언트와 도커 데몬

도커의 전체적인 구조에 대해서 간략하게 알아보자.

![docker architecture](/assets/img/2023-12-20-docker-and-vm/docker-architecture.webp)

도커를 사용해봤다면, 실행중인 컨테이너 목록을 보기 위해 'docker ps', 저장된 도커 이미지를 보기 위해 'docker images', 이미지를 실행하기 위해 'docker run -d ~~~'라는 명령어를 입력해본 적이 있을 것이다.

이는 모두 도커 클라이언트가 사용자가 원하는 명령을 입력할 수 있는 환경을 CUI로써 제공해주기 때문이다.

docker ps와 같은 명령어를 입력하게 되면 수행되는 과정은 다음과 같다.

1. docker ps 명령어 입력
2. /usr/bin/docker 는 /var/run/docker.sock 유닉스 소켓을 사용해서 도커 데몬에게 명령어 전달
3. 도커 데몬은 명령어를 파싱하고, 해당하는 작업을 수행한다.
4. 수행 결과를 도커 클라이언트에게 반환하고, 사용자에게 결과를 출력한다.

추가적인 옵션이 있다면 위 과정에서 변동 될 수 있겠지만, 전체적인 흐름은 도커 클라이언트 -> 도커 데몬 -> 응답의 과정이라고 할 수 있다.

## 도커가 컨테이너에 자원을 할당하는 방법

실행 중인 컨테이너의 자원 할당 정보를 확인하기 위해서는 'docker stats' 명령어를 사용한다.

### **메모리 할당**

![docker ps](/assets/img/2023-12-20-docker-and-vm/docker-ps.webp)

나는 resumarble이라는 컨테이너에 대한 정보를 확인하기 위해 'docker stats resumarble'이라고 입력했다.

![docker stats](/assets/img/2023-12-20-docker-and-vm/docker-stats.webp)

또한 이미지를 컨테이너로 실행할 때 --memory 옵션을 이용하면 원하는 메모리만큼 컨테이너에 할당할 수 있다.

> docker run -d -p 8080:8080 waveofmymind/resumarble:2.0 --memory 200m

200MiB만큼 컨테이너에 메모리를 할당한다는 명령어이다.

스왑 메모리는 지정하지 않을 경우, --memory 옵션으로 할당한 메모리의 2배로 설정된다.

### **CPU 자원 할당**

> -c(--cpu-shares)

-c 옵션은 가중치를 의미하며, 예를 들어 1024로 할당한 컨테이너와 512로 할당한 컨테이너가 있을 경우 전자가 2배 더 많은 CPU 자원을 할당 받는다.

> --cpus

실제 면접에서 받았던 질문으로, CPU 코어의 숫자를 직접 지정하는 옵션이다.

10진수를 지정하면 코어의 개수를, 소수로 지정하면 비율을 의미한다.

## 작성 중입니다.







## 레퍼런스

- [도커와 VM의 차이점은 무엇인가요?](https://aws.amazon.com/ko/compare/the-difference-between-docker-vm/)

- [20분 만에 전공자처럼 도커, 가상화 이해하기!](https://youtu.be/zh0OMXg2Kog?si=z3xVnF56e8ByktG7)


