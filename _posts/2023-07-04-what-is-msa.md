---
title: "MSA의 트랜잭션 패턴"
date: 2023-07-04 09:29:00 +0900
aliases: 
tags: [MSA,Micro Service]
categories: [Spring]
---

마이크로 서비스 아키텍처에서 가장 어려운 해결 과제인 트랜잭션 처리에 대해서 학습한 것을 공유하는 글입니다.

## AS-IS

기존 모놀리식 아키텍처에서 트랜잭션이란, 하나의 DB를 사용하기 때문에 구현하는 것은 어렵지 않았습니다.

하나의 서비스를 기능 위한 여러 쿼리들의 발생을 하나의 논리적인 단위로 묶는 것을 트랜잭션이라고 하는데요.

그렇기 때문에 하나의 비즈니스 로직에서 트랜잭션으로 묶을 경우, 해당 로직을 실행중인 여러 로직 중 하나만 잘못되어도 전체 롤백 처리를 하면 됩니다.

이는 하나의 거대한 프로세스로 실행중인 모놀리식 아키텍처이기 때문에 가능한 방법입니다.

MSA에서는 여러 서비스들이 프로세스가 나뉘어서 실행중이기때문에 그만큼 DB를 서비스마다 나누어 쓰는 경우가 많기 때문에 그에 따라서 하나의 비즈니스 로직을 처리하는데 여러 서비스의 기능이 수행되어야되는 경우 생각해야할 것이 많아집니다.

그래서 트랜잭션 패턴이라는게 존재하는데요. 그에 대해서 알아보겠습니다.

## 트랜잭션 패턴

> MSA 설계를 통해 도출된 서비스를 사용하여 트랜잭션을 해결해주기 위한 패턴

여러 서비스가 각 역할을 처리하여 하나의 일련된 비즈니스 로직을 실행하기 위해 기능하기 때문에 트랜잭션 처리는 중요해집니다.

송금이라는 케이스의 경우, 회원 서비스에서 송금인의 계좌번호를 체크하고, 계좌 확인 서비스에서 보내는 사람의 계좌를 확인하고, 최종적으로는 송금 서비스에서 송금이 이루어지게 됩니다.

그러나 3개의 서비스 중 어느 하나라도 응답에 실패할 경우 각 서비스마다 DB에 저장된 데이터에 대해 어떻게 롤백을 시킬 것인가를 고려해야합니다.

이에 대해 등장한 것이 트랜잭션 패턴입니다.

### 2PC(2Phase Commit)

트랜잭션의 완료를 2단계에 거쳐서 결정합니다.

Commit Request(1페이즈)하는 작업이 추가되어, 이에 대한 모든 작업이 성공 유무를 판단(2페이즈)하는 과정이 추가됩니다.

실패할 경우 1페이즈에서 했던 행동들이 무시됩니다.

그러나 이러한 점은 2페이즈를 판단하는 코디네이터에 대한 관리가 필요합니다.

### Compensating Transactions(보상 트랜잭션)

특정 요청과 그 요청에 대해 정상적이고 완전히 종료된 "행동"(트랜잭션)을 그 이전 상태로 되돌리기 위한 "행동"(트랜잭션)을 위한 것입니다.

송금 서비스에서 보상 트랜잭션을 나타내면,

송금 요청이 들어왔을때, 송금 서비스 -> 계정 서비스 -> 계좌 확인 서비스에 거쳐서 송금이 이루어진다고 가정해봅시다.

만약 계좌 확인서비스에서 실패를 할 경우, 앞서 진행되었던 송금 서비스에 대해 보상 트랜잭션을 발생시킵니다.

이 때 미리 정의해놓은 서비스에 한해서만 보상 트랜잭션을 실행시킬 수 있습니다.

그러나, 이러한 점은 한가지 큰 문제가 있습니다.

보상 트랜잭션 자체도 서로 다른 서비스간의 통신이기 때문에, 송금 서비스에서 이러한 보상 트랜잭션을 받지 못할 가능성이 있습니다.

그렇기 때문에 비동기 처리나, 최대한 보상 트랜잭션을 구현하지 않는 방법을 고려해보는 것이 요구됩니다.

### Saga Pattern(사가 패턴)

트랜잭션의 선, 후 관계를 사전에 정의하고, 필요와 경우에 따라 코디네이터가 보상 트랜잭션을 이용, 관리하여 분산 시스템 환경에서 트랜잭션을 구현하기 위한 패턴입니다.

작성 중















