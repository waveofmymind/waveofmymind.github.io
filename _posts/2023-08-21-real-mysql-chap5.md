---
title: "Real MySQL 8.0 - 트랜잭션과 잠금"
date: 2023-08-21 20:12:00 +0900
aliases: 
tags: [Transaction,Lock,MySQL,Real MySQL 8.0]
categories: [DB]
---

Real MySQL 8.0의 챕터 5. 트랜잭션과 잠금을 읽고 나중에 기억할만한 것들을 정리한 글입니다.

## 서론

트랜잭션은 작업의 원자성을 보장해주는 것, 보장해주지 못할 경우 Partial update가 발생한다.

락과 트랜잭션은 비슷한 개념같지만 다르다.

**락** -> 동시성을 제어하기 위한 기능
**트랜잭션** -> 데이터의 정합성을 보장하기 위한 기능

## 트랜잭션

하나의 트랜잭션 내에 쿼리가 한개여도 트랜잭션의 가치는 소중하다.

**원자성**을 보장하기 때문

원자성을 테스트해보기 위해 다음과 같은 SQL이 있다.

```sql
INSERT INTO tab_innodb (fdpk) VALUES (3);

# 커밋 후 아래 커맨드 입력

INSERT INTO tab_innodb (fdpk) VALUES (1),(2),(3);
ERROR 1062(23000): Duplicate entry '3' for key 'PRIMARY'

# 결과는 기존의 3 하나만 남아있다.
```

1,2가 입력되고 3이 입력되려 하지만 기존에 3이 있으므로, PK 중복 에러로 트랜잭션이 롤백되고 1,2,3 전부 INSERT가 수행되지 않는다.

## 주의사항

트랜잭션의 범위를 최소화하라.

만약 게시글을 등록하는 로직이 있을 때, 게시글 유효성 확인이나 로그인 체크와 같은 것은 데이터를 저장하는 것이 아니며,

게시 후 알림 메일을 전송하는 것과 같은 네트워크 통신 과정은 트랜잭션 범위에서 제거해야한다.

## **MySQL 엔진의 잠금**

MySQL에서의 잠금은 크게 스토리지 엔진의 잠금, MySQL 엔진의 잠금으로 나눌 수 있다.

### 글로벌 락(Global Lock)

> FLUSH TABLES WITH READ LOCK

MySQL에서 제공하는 범위가 가장 큰 잠금이다.

한 세션에서 글로벌 락을 획득하면, 다른 DDL,DML 문장은 락이 해제될 때까지 대기상태로 빠진다.

또한 작업 대상의 테이블이나 데이터베이스가 다르더라도 영향을 미친다.

범위가 크므로, 가급적 사용하지 말자.

또한 트랜잭션이 존재하기 때문에 일관성을 지키기 위해 다른 모든 데이터의 변경 작업을 멈출 필요는 없다.

### 테이블 락(Table Lock)

> LOCK TABLES table_name [ READ | WRITE ]

개별 테이블 단위로 설정되는 잠금

`UNLOCK TABLES` 명령으로 잠금을 반납할 수 있으며, 온라인 작업에 상당한 영향을 미치기 때문에 가급적 권장하지 않는다.

또한 InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공한다.

### 네임드 락(Named Lock)

> GET_LOCK()

임의의 문자열에 대해 잠금을 설정할 수 있다.

### 메타데이터 락(Metadata Lock)

데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금

## InnoDB 스토리지 엔진의 잠금

레코드 기반의 잠금 방식을 제공한다.

### 자동 증가 락

AUTO_INCREMENT 컬럼 속성을 제공하는 특성상,

동시에 여러 레코드가 INSERT 요청이 들어올 경우 중복되지않고 순차적인 PK를 가지기 위해 내부적으로 테이블 수준의 잠금을 사용한다.

UPDATE, DELETE의 경우에는 사용되지 않는다.

### **인덱스와 잠금**

InnoDB는 레코드를 잠금하지 않고 인덱스를 잠금하는데,

UPDATE시 지정한 조건에 인덱스가 있을 경우 인덱스에 해당하는 모든 레코드를 잠금한다.

인덱스를 적절히 준비하지 않을 경우 동시성이 떨어지는 문제가 발생하는 것이다.

반대로 인덱스가 하나도 없을 경우, 테이블 풀 스캔이 작동하며, 모든 레코드에 대해 잠금이 걸린다.












