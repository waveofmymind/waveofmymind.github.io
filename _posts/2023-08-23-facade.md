---
title: "SRP를 지키기 위한 파사드 패턴 적용기"
date: 2023-08-23 09:29:00 +0900
aliases: 
tags: [Facade,Design Pattern]
categories: [Spring]
---

면접 예상 질문 서비스를 구현하면서 Controller 단에 많은 서비스 인터페이스가 사용되게 되었고,

이를 개선하고자 `Facade`패턴을 적용하게 된 글을 공유하고자합니다.

## **AS-IS**

우선 이번 글에서 다루게 된 클래스, `ResumeController`입니다.

```kotlin
@RestController
class ResumeController(
	private val promptService: PromptService,
	private val requestFormMapper: RequestFormMapper,
	private val completionService: CompletionService,
	private val objectMapper : ObjectMapper
) {
	// ...
}
```

면접 예상 질문을 생성하기 위해서는 다음과 같은 로직이 수행됩니다.

1. 해당하는 프롬프트를 조회한다.
2. 조회한 프롬프트를 사용해서 매퍼 클래스를 이용해 컴플리션 데이터를 생성한다.
3. AI 서비스를 이용하기 위해 OpenFeign을 사용해서 요청한다.
4. 응답 JSON 데이터를 ObjectMapper를 사용해서 바인딩한다.

즉, 사용되어야 하는 서비스 인터페이스만

- PromptService
- RequestFormMapper
- CompletionService
- ObjectMapper

이기 때문에, 이를 어느 한 인터페이스에서 몰아서 사용하는 것 보다, Controller 클래스에서 의존하여 사용하게 되었습니다.

그러나 이러한 점은 추가적인 클래스가 필요할 때 문제가 되었는데요.

CompletionMapper라는 DTO를 변환해주는 매퍼 클래스를 하나 추가하게 되었고, 이는 마찬가지로 ResumeController의 생성자 주입을 통해 사용하는 것이 자명했습니다.

그러던 중 인프콘에서 들었던 세션에서, SOLID에 대한 내용이 떠올랐습니다.

![confuse](/assets/img/2023-08-23-facade/confuse.webp)

**SRP 원칙을 지키지 못하고 있는 것이 아닌가?** 

즉, 클래스의 변경 이유는 단 하나로 귀결되어야 한다는 이 원칙은, 당연스럽게도 'ResumeController에서는 지켜지지 않고 있다' 라는 생각이 들었습니다.

**사용자의 요청으로 면접 예상 질문을 생성한다** 라는 협력을 두고 역할을 새로 나누어 책임을 전가할 경우, 새로운 클래스가 추가되기 때문에

이는 ResumeController에 추가되고, 점점 의존하는 클래스들이 많아지고 있었습니다.

그래서 저는 이러한 점을 덜어내고자 애플리케이션 계층과 프레젠테이션 계층 사이에 한가지 인터페이스를 두는 것이 좋겠다는 생각이 들었습니다.

개인적을 생각했을 때, Facade 패턴이 이 문제점을 해결해줄 수 있을 것 같았습니다.

## **Facade 패턴**

> 다른 클래스들의 복잡한 집합에 대한 단순화된 인터페이스를 제공하는 구조적 디자인 패턴

![introduce](/assets/img/2023-08-23-facade/introduce.webp)

다양한 서비스 인터페이스를 의존하여 사용하는 컨트롤러에서, 중간에 퍼사드라고 하는 하나의 계층을 두어 컨트롤러에서는 하나의 인터페이스만을 제공하기 위해서 사용될 수 있습니다.

## 작성중

## **TO-BE**
